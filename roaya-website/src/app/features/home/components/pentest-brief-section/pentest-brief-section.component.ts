import {
  Component,
  AfterViewInit,
  OnDestroy,
  ElementRef,
  ViewChild,
  signal,
  ChangeDetectionStrategy,
  PLATFORM_ID,
  inject
} from '@angular/core';
import { CommonModule, isPlatformBrowser } from '@angular/common';
import { RouterLink } from '@angular/router';
import { TranslateModule } from '@ngx-translate/core';
import { NgIcon, provideIcons } from '@ng-icons/core';
import { gsap } from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';
import {
  lucideShield,
  lucideFileText,
  lucideCheckCircle,
  lucideZap,
  lucideArrowRight,
  lucideUsers,
  lucideClock,
  lucideTerminal,
  lucideSearch,
  lucideBug
} from '@ng-icons/lucide';

/**
 * Penetration Testing Brief Section Component
 *
 * Terminal/hacker aesthetic with matrix rain effects.
 * Features typing animation and scan-line overlays.
 */
@Component({
  selector: 'app-pentest-brief-section',
  standalone: true,
  imports: [CommonModule, RouterLink, TranslateModule, NgIcon],
  templateUrl: './pentest-brief-section.component.html',
  styleUrl: './pentest-brief-section.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [
    provideIcons({
      lucideShield,
      lucideFileText,
      lucideCheckCircle,
      lucideZap,
      lucideArrowRight,
      lucideUsers,
      lucideClock,
      lucideTerminal,
      lucideSearch,
      lucideBug
    })
  ]
})
export class PentestBriefSectionComponent implements AfterViewInit, OnDestroy {
  @ViewChild('sectionElement') sectionElement!: ElementRef<HTMLElement>;
  @ViewChild('terminalOutput') terminalOutput!: ElementRef<HTMLDivElement>;

  private readonly platformId = inject(PLATFORM_ID);
  private scrollTriggers: ScrollTrigger[] = [];
  private animations: gsap.core.Tween[] = [];
  private typingInterval: ReturnType<typeof setInterval> | null = null;

  prefersReducedMotion = signal(false);
  terminalLines = signal<string[]>([]);
  showCursor = signal(true);

  // Terminal commands for typing animation
  private readonly terminalCommands = [
    '> Initializing penetration test...',
    '> Target: client-network.local',
    '> Running vulnerability scan...',
    '> [+] Found 12 potential vulnerabilities',
    '> [!] Critical: SQL Injection in /api/users',
    '> [!] High: XSS in search parameter',
    '> Generating detailed report...',
    '> Assessment complete. Report ready.'
  ];

  // Highlights configuration
  highlights = [
    {
      icon: 'lucideSearch',
      titleKey: 'home.serviceBriefs.pentesting.highlights.assessment.title',
      descriptionKey: 'home.serviceBriefs.pentesting.highlights.assessment.description'
    },
    {
      icon: 'lucideFileText',
      titleKey: 'home.serviceBriefs.pentesting.highlights.reporting.title',
      descriptionKey: 'home.serviceBriefs.pentesting.highlights.reporting.description'
    },
    {
      icon: 'lucideCheckCircle',
      titleKey: 'home.serviceBriefs.pentesting.highlights.remediation.title',
      descriptionKey: 'home.serviceBriefs.pentesting.highlights.remediation.description'
    },
    {
      icon: 'lucideZap',
      titleKey: 'home.serviceBriefs.pentesting.highlights.continuous.title',
      descriptionKey: 'home.serviceBriefs.pentesting.highlights.continuous.description'
    }
  ];

  // Stats configuration
  stats = [
    { value: '500+', labelKey: 'home.serviceBriefs.pentesting.stats.assessments', icon: 'lucideShield' },
    { value: '48h', labelKey: 'home.serviceBriefs.pentesting.stats.delivery', icon: 'lucideClock' }
  ];

  ngAfterViewInit(): void {
    if (!isPlatformBrowser(this.platformId)) return;

    gsap.registerPlugin(ScrollTrigger);

    this.prefersReducedMotion.set(
      window.matchMedia('(prefers-reduced-motion: reduce)').matches
    );

    if (!this.prefersReducedMotion()) {
      // Use requestAnimationFrame for reliable DOM state
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          this.initAnimations();
        });
      });
    }

    // Start cursor blink
    this.startCursorBlink();
  }

  ngOnDestroy(): void {
    this.cleanup();
    if (this.typingInterval) {
      clearInterval(this.typingInterval);
    }
  }

  private startCursorBlink(): void {
    setInterval(() => {
      this.showCursor.update(v => !v);
    }, 530);
  }

  private initAnimations(): void {
    const section = this.sectionElement?.nativeElement;
    if (!section) return;

    // Get all animatable elements
    const terminal = section.querySelector('.terminal-window');
    const content = section.querySelector('.pentest-content');
    const highlights = section.querySelectorAll('.pentest-highlight');
    const stats = section.querySelectorAll('.pentest-stat');

    // Set initial hidden state
    gsap.set(terminal, { opacity: 0, y: 30, scale: 0.95 });
    gsap.set(content, { opacity: 0, x: 50 });
    gsap.set(highlights, { opacity: 0, x: -30 });
    gsap.set(stats, { opacity: 0, scale: 0.8 });

    // Animation function
    const playAnimation = () => {
      // Animate terminal window
      gsap.to(terminal, {
        opacity: 1,
        y: 0,
        scale: 1,
        duration: 0.8,
        ease: 'back.out(1.7)'
      });

      // Start typing animation after terminal appears
      setTimeout(() => {
        this.startTypingAnimation();
      }, 800);

      // Animate content with slight delay
      gsap.to(content, {
        opacity: 1,
        x: 0,
        duration: 0.8,
        ease: 'power3.out',
        delay: 0.3
      });

      // Stagger highlights
      gsap.to(highlights, {
        opacity: 1,
        x: 0,
        duration: 0.5,
        stagger: 0.12,
        ease: 'power3.out',
        delay: 0.6
      });

      // Animate stats
      gsap.to(stats, {
        opacity: 1,
        scale: 1,
        duration: 0.6,
        stagger: 0.15,
        ease: 'back.out(1.7)',
        delay: 1
      });

      this.animateStatCounters(section);
    };

    // Check if section is already in viewport
    const rect = section.getBoundingClientRect();
    const isInViewport = rect.top < window.innerHeight && rect.bottom > 0;

    if (isInViewport) {
      // Section already visible - play immediately
      playAnimation();
    } else {
      // Use ScrollTrigger for sections below viewport
      const sectionTrigger = ScrollTrigger.create({
        trigger: section,
        start: 'top 90%',
        onEnter: playAnimation,
        once: true
      });

      this.scrollTriggers.push(sectionTrigger);

      // Fallback: if ScrollTrigger doesn't fire within 2 seconds, show content anyway
      setTimeout(() => {
        if (highlights.length > 0 && window.getComputedStyle(highlights[0] as Element).opacity === '0') {
          playAnimation();
        }
      }, 2000);
    }
  }

  private startTypingAnimation(): void {
    let currentLine = 0;
    let currentChar = 0;
    const lines: string[] = [];

    const typeNextChar = () => {
      if (currentLine >= this.terminalCommands.length) {
        if (this.typingInterval) {
          clearInterval(this.typingInterval);
        }
        return;
      }

      const command = this.terminalCommands[currentLine];

      if (currentChar <= command.length) {
        lines[currentLine] = command.substring(0, currentChar);
        this.terminalLines.set([...lines]);
        currentChar++;
      } else {
        currentLine++;
        currentChar = 0;
        if (currentLine < this.terminalCommands.length) {
          lines.push('');
        }
      }
    };

    this.typingInterval = setInterval(typeNextChar, 40);
  }

  private animateStatCounters(section: HTMLElement): void {
    const statValues = section.querySelectorAll('.pentest-stat-value');

    statValues.forEach((element) => {
      const targetText = element.textContent?.trim() || '';
      const numericMatch = targetText.match(/[\d,]+\.?\d*/);

      if (numericMatch) {
        const targetValue = parseFloat(numericMatch[0].replace(/,/g, ''));
        const suffix = targetText.replace(/[\d,]+\.?\d*/, '');

        const counter = { value: 0 };
        gsap.to(counter, {
          value: targetValue,
          duration: 2,
          ease: 'power2.out',
          delay: 1.2,
          onUpdate: () => {
            const currentValue = counter.value;
            const formattedValue = currentValue % 1 === 0
              ? Math.round(currentValue)
              : currentValue.toFixed(1);
            element.textContent = formattedValue + suffix;
          }
        });
      }
    });
  }

  private cleanup(): void {
    this.scrollTriggers.forEach(trigger => trigger.kill());
    this.animations.forEach(anim => anim.kill());
    this.scrollTriggers = [];
    this.animations = [];
  }

  trackByIndex(index: number): number {
    return index;
  }

  getLineClass(line: string): string {
    if (line.includes('[+]')) return 'text-green-400';
    if (line.includes('[!] Critical')) return 'text-red-400';
    if (line.includes('[!] High')) return 'text-orange-400';
    if (line.includes('complete')) return 'text-cyan-400';
    return 'text-green-300';
  }
}
